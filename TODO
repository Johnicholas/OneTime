ToDo list for OneTime.  (We should probably get a real bug tracker.)

* There seem to be two styles of 'raise' call in the code.  Consistify.

* Likewise with "\\\n(" vs "(\n" in function calls.  Latter is preferred.

* "onetime -d -p PAD INPUT -o OUTPUT" should work

  Putting input argument before last option should work.  Why doesn't it?

* Off-by-one-error when when adding the next encrypted length each time?

  Try encrypting long-msg multiple times, watch the used range climb
  by "length(long-msg) - 1" each time.

  Preliminary investigation indicates there's no bug here.  Confirm.

* Failed decryption should create no output file, not create 0-byte file.

* Look at environment variables as well as options, for things like
  config location, etc.

* Make pad-records file location potentially independent of config dir.

* Yo.  Wrap those base64 lines with newlines.  Hmm, they *are* wrapped
  in v1 output; why is v2 different?  Apparently because of r145, when
  base64.encodestring() was replaced with base64.b64encode(), for
  reasons not clear in the comments or log message.  Make sure that
  undoing that is okay before undoing.

* Put a 'version' file in ~/.onetime, so that future versions of
  onetime can notice what the previously-installed version was (absent
  means 1, of course) and make the appropriate recommendations.

* Solution to the Pad ID question:

  The question is whether or not to include a Pad ID in the output
  (1.x does).  While mathematically there is probably little security
  risk to doing so, since the 1.x Pad ID is a checksum of a stretch of
  pad that is much longer than the checksum result, in practice some
  people are understandably uncomfortable with it, since technically
  it reveals something (however trivial) about the pad data.

  One possible solution would be to simply not include the Pad ID in
  the output.  However, leads to inconvenience in some use cases: now
  you can't check the Pad ID of an incoming message; you have no
  canonical, tool-encouraged way of talking about pads with your
  interlocutors (see the '--show-pad-id' option); onetime loses the
  potential to detect a certain error condition ("You're using the
  wrong pad") at the start of decryption; etc.

  So we'd like to keep the Pad ID in the output.  (Note it's always
  used in the pad-records file, and there's really no way to avoid it
  there, since we have to track used and unused ranges.  But the
  pad-records file is supposed to be private.)

  The real solution is to compute a the Pad ID from a much smaller
  length of data at the start of the pad -- a length equal to or
  greater than the checksum result length, but not by much -- and then
  *never use that part of the pad data* for encryption.  If the pad
  data is truly random, then whatever comes after the stretch used to
  compute the checksum is not dependent in any way on that stretch.
  Therefore even the (IMHO strictly hypothetical) tiny bit of
  information leaked by a checksum would be of literally zero
  consequence, since none of that part of the pad would ever be used
  for anything besides computing the Pad ID.  And this doesn't cost us
  much: the bit of pad consumed for this is just N bytes from the
  front of the file, once -- it doesn't increase as successive ranges
  are used for encrcyption/decryption.

  So that's the way we're going to do it.

  However, it raises a compatibility issue: new 2.x Pad IDs will be
  computed differently from 1.x Pad IDs.  A compatibility shim is
  needed to deal with this:

     1) In pad-records, put a version attribute on the <id> element:
        <id version="2">, so we can recognize 1.x vs 2.x IDs.

     2) When writing a Pad ID to pad-records, write only the 2.x ID.

     3) When reading in a pad record, if the 'version' attribute is
        not present, we're dealing with a 1.x ID.  Make sure to check
        for this in step (4).

     4) When reading in a pad, compute both the 1.x ID and the 2.x ID.
        Then check the pad's record: if the pad offset is less than L
        (where L is the length of the data used to compute the 2.x
        ID), then manually advance the pad offset past L.

     5) The '--show-pad-id' option is new in 2.x, but when run on a
        pad for which a 1.x entry is present in pad-records, then it
        should still show the 1.x ID too (with an explanatory note).

   Steps 1-4 will need regression tests.
