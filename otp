#!/usr/bin/env python

# Encoder/decoder for one-time pads.  See usage() for details.

import os
import sys
import stat
import getopt
import bz2
import base64
import sha
import re
import xml
import xml.dom
import xml.dom.minidom


# Pretend we have true booleans on older Python versions.
try:
  True
except:
  True = 1
  False = 0


class Pad:
  """An encoder/decoder associated with a specific pad at a specific offset.
  Feed bytes through convert() to XOR them against the pad."""
  def __init__(self, pad_path):
    """Initialize a new pad, using padfile PAD_PATH.  The pad cannot be
  used for encoding or decoding until set_offset() is called."""
    self.pad_path = pad_path
    self.padfile = open(pad_path)
    self.pad_size = os.stat(self.pad_path)[stat.ST_SIZE]
    self._length = 0  # number of pad bytes used this time
    self._id = self._get_id(self.padfile)
    self._offset = None
    
  class PadBad(Exception):
    """Exception raised if the Pad is asked to do something Bad."""
    pass

  def set_offset(self, offset):
    """Set this pad's encoding/decoding offset to OFFSET."""
    if offset >= self.pad_size:
      raise PadBad
    self._offset = offset
    self.padfile.seek(self._offset)

  def convert(self, str):
    """Return a new string that is STR XORed against the pad."""
    pad_str = self.padfile.read(len(str))
    result = ''
    for i in range(len(str)):
      result = result + chr(ord(str[i]) ^ ord(pad_str[i]))
    self._length += len(str)
    return result

  def _get_id(self, padfile):
    """Get the ID (the SHA1 of its first kilobyte) for this pad."""
    saved_posn = self.padfile.tell()
    self.padfile.seek(0)
    sha1 = sha.new()
    str = self.padfile.read(1024)
    sha1.update(str)
    self.padfile.seek(saved_posn)
    return sha1.hexdigest()

  def id(self):
    """Return the pad's ID."""
    return self._id

  def path(self):
    """Return the pad's path."""
    return self.pad_pat

  def offset(self):
    """Return offset from which encoding/decoding started."""
    return self._offset

  def length(self):
    """Return the number of pad bytes used so far."""
    return self._length


class PadEncoder:
  """Class for encoding raw data to OTP output."""

  class PadEncoderNotFinished(Exception):
    """Exception raised if the encoder is asked for information it
    doesn't have yet, such as the final encoded length."""
    pass

  def __init__(self, pad, config):
    """Initialize an encoder for PAD with Configuration CONFIG."""
    self.pad = pad
    self.config = config
    self.compressor = bz2.BZ2Compressor()
    self.finished = 0

  def _output(self, compressed_str):
    "Return encoding of COMPRESSED_STR, or None if COMPRESSED_STR is empty."
    if compressed_str:
      return base64.encodestring(compressed_str)
    else:
      return None

  def encode(self, str):
    """Return all available otp-encoded data so far, including for STR,
    or return None if no encoded data is ready yet."""
    return self._output(self.compressor.compress(self.pad.convert(str)))

  def finish(self):
    "Return last of encoding of COMPRESSED_STR, or None if none left."
    self.finished = 1
    last_bits = self._output(self.compressor.flush())
    self.config.consume(self.pad, False)
    return last_bits


class PadDecoder:
  """todo: write this doc string"""
  def __init__(self, pad, config):
    """Initialize a decoder for PAD with Configuration CONFIG."""
    self.pad = pad
    self.config = config
    self.decompressor = bz2.BZ2Decompressor()
    self.unused_data = ""

  def decode(self, str):
    """Return all available otp-decoded data so far, including for STR,
    or return None if no decoded data is ready yet.  Throw EOFError
    exception if called past the end of decodable data.  Store any
    unused data in self.unused_data."""
    ### todo: we're not really doing that unused_data thing, are we?
    return self.pad.convert((self.decompressor.decompress
                             (base64.decodestring(str))))

  def finish(self):
    """Finalize pad usage with the configuration."""
    self.config.consume(self.pad, True)


class Configuration:
  """A parsed representation of one user's ~/.otp/ configuration area.
  A .otp/ directory contains just a 'pads' file right now."""
  def __init__(self, path=None):
    """Initialize a new configuration.  If PATH is None, try to find
  the config area based on the runtime environment.  Otherwise, PATH
  should be a path to a .otp/ directory."""
    self.config_area = path
    if not self.config_area:
      self.config_area = os.path.join(os.path.expanduser("~"), ".otp")
    self.pads_file = os.path.join(self.config_area, "pads")
    self.pads = self._parse_pads()

  class ConfigurationError(Exception):
    """Exception raised if we encounter an impossible state in a
    Configuration."""
    pass

  def _consolidate_used_ranges(self, used, allow_reconsumption=False):
    """Return a consolidated version of USED.  USED is a list of
    tuples, indicating offsets and lengths:

       [ (OFFSET1, LENGTH1), (OFFSET2, LENGTH2), ... ]

    Consolidation means returning a list of equal or shorter length,
    that marks exactly the same ranges as used, but expressed in the
    most compact way possible.  For example:

       [ (0, 10), (10, 20), (20, 25) ]

    would become

       [ (0, 25) ]

    If ALLOW_RECONSUMPTION is False, raise a ConfigurationError
    exception if the data are incoherent, such as a range beginning
    inside another range.  But if ALLOW_RECONSUMPTION is True, allow
    ranges to overlap.  Typically, it will be False when encoding and
    True when decoding, because it's legitimate to decode a message
    multiple times, as long as no one re-uses that range for encoding."""
    new_used = [ ]
    last_offset = None
    last_length = None
    for tup in used:
      (this_offset, this_length) = tup
      if last_offset is not None:
        if last_offset + last_length > this_offset:
          if not allow_reconsumption:
            raise self.ConfigurationError, \
                  "pad's used ranges are incoherent:\n   %s" % str(used)
          else:
            last_length = (this_offset - last_offset) + this_length
        else:
          new_used.append((last_offset, last_length))
          last_offset = this_offset
          last_length = this_length
      else:
        last_offset = this_offset
        last_length = this_length
    if last_offset is not None:
      new_used.append((last_offset, last_length))
    return new_used

  def _get_next_offset(self, used):
    """Get the next free offset from USED, which is assumed to be in
    consolidated form."""
    cur_offset = None
    # We don't do anything fancy, just get the earliest available
    # offset past the last used tuple.  This means that any ranges in
    # between tuples are wasted.
    for tup in used:
      (this_offset, this_length) = tup
      cur_offset = this_offset + this_length
    if cur_offset is None:
      return 0
    else:
      return cur_offset
    
  def _parse_pads(self):
    """Return a dictionary representing a 'pads' file (e.g., ~/.otp/pads).
    The dictionary is keyed on IDs, whose values are sub-dictionaries,
    whose keys are the remaining element names inside a pad, where the
    value of the 'used' element is a list of tuples, each tuple of the
    form (OFFSET, LENGTH).  So:

       dict[SHA1_SUM] ==> subdict
       subdict['path'] ==> PATH_VALUE
       subdict['used'] ==> [(OFFSET1, LENGTH1), (OFFSET2, LENGTH2), ...]

    A 'pads' file is an XML document like this:

      <?xml version="1.0" encode="UTF-8"?>
      <!DOCTYPE TYPE_OF_DOC SYSTEM/PUBLIC "dtd-name">
      <otp-pads>
         <pad>
           <id>SHA1_HASH_OF_FIRST_KILOBYTE_OF_PAD</id>
           <path>ABS_PATH_TO_PAD</path>
           <used><offset>OFFSET_A</offset>
                 <length>LENGTH_A</length></used>
           <used><offset>OFFSET_B</offset>
                 <length>LENGTH_B</length></used>
           ...
         </pad>
         <pad>
           <id>SHA1_HASH_OF_FIRST_KILOBYTE_OF_PAD</id>
           <path>ABS_PATH_TO_PAD</path>
           <used><offset>OFFSET_C</offset>
                 <length>LENGTH_C</length></used>
           ...
         </pad>
         ...
      </otp-pads>
      """
    dom = xml.dom.minidom.parse(self.pads_file)
    dict = { }

    for pad in dom.firstChild.childNodes:
      id = None
      path = None
      used = [ ]
      if pad.nodeType == xml.dom.Node.ELEMENT_NODE:
        for pad_part in pad.childNodes:
          if pad_part.nodeType == xml.dom.Node.ELEMENT_NODE:
            if pad_part.nodeName == "id":
              id = pad_part.childNodes[0].nodeValue
            elif pad_part.nodeName == "path":
              path = pad_part.childNodes[0].nodeValue
            elif pad_part.nodeName == "used":
              offset = None
              length = None
              for used_part in pad_part.childNodes:
                if used_part.nodeName == "offset":
                  offset = int(used_part.childNodes[0].nodeValue)
                if used_part.nodeName == "length":
                  length = int(used_part.childNodes[0].nodeValue)
              used.append((offset, length))
            else:
              ### todo: or error on unrecognized element?
              pass
        subdict = { }
        subdict["path"] = path
        subdict["used"] = self._consolidate_used_ranges(used)
        dict[id] = subdict
    return dict
    
  def save(self):
    """Save the pads file."""
    tempfile = self.pads_file + ".tmp"
    fp = open(tempfile, 'w')
    fp.write("<otp-pads>\n")
    for pad in self.pads.keys():
      fp.write("  <pad>\n")
      fp.write("    <id>%s</id>\n" % pad)
      fp.write("    <path>%s</path>\n" % self.pads[pad]["path"])
      for tuple in self._consolidate_used_ranges(self.pads[pad]["used"]):
        fp.write("    <used><offset>%d</offset>\n" % tuple[0])
        fp.write("          <length>%d</length></used>\n" % tuple[1])
      fp.write("  </pad>\n")
    fp.write("</otp-pads>\n")
    os.rename(tempfile, self.pads_file)

  def register(self, pad):
    """Register PAD if it is not already registered, and set its
    offset based on previously used regions for that pad, if any."""
    if not self.pads.has_key(pad.id()):
      subdict = { "path" : pad.path(), "used" : [ ] }
      self.pads[pad.id()] = subdict
    pad.set_offset(self._get_next_offset(self.pads[pad.id()]["used"]))

  def consume(self, pad, allow_reconsumption):
    """Record that PAD has used PAD.length() bytes starting at PAD.offset().

    If ALLOW_RECONSUMPTION is False, raise a ConfigurationError
    if reconsuming any part of a range that has been consumed previously.
    But if ALLOW_RECONSUMPTION is True, allow ranges to overlap.
    Typically, it is be False when encoding and True when decoding,
    because it's okay to decode a message multiple times, but not
    re-use a range for encoding."""
    used = self.pads[pad.id()]["used"]
    used.append((pad.offset(), pad.length()))
    self.pads[pad.id()]["used"] = self._consolidate_used_ranges\
                                  (used, allow_reconsumption)
    pass

  def show_pads(self):
    """Print pads configuration, presumably for debugging."""
    for pad in self.pads.keys():
      print "Pad %s:" % pad
      print "  path: \"%s\"" % self.pads[pad]["path"]
      print "  used:", self.pads[pad]["used"]


def usage():
  """Return a usage string."""
  return """Usage: otp [-e|-d] PAD_FILE < INPUT > OUTPUT
         
Encoder/decoder for one-time pads.  Encoding and decoding are not
symmetrical, because otp compresses plaintext input to save pad.
Thus, otp needs to be told whether it is encoding or decoding.

Use --offset=N option to control pad data start offset.

Use --config=DIR to use DIR (instead of ~/.otp) as the config area.
"""


def main():
  encrypting  = False
  decrypting  = False
  offset      = 0
  config_area = None
  debug       = False

  try:
    opts, args = getopt.getopt(sys.argv[1:],
                               'edh?vVC:',
                               [ "encrypt", "decrypt",
                                 "offset=",
                                 "config=",
                                 "debug",
                                 "help", "version"])
  except getopt.GetoptError, e:
    sys.stderr.write("Error: '%s'\n" % str(e))
    sys.exit(1)


  for opt, value in opts:
    if opt == '--help' or opt == '-h' or opt == '-?':
      usage()
      sys.exit(0)
    elif opt == '--version' or opt == '-v' or opt == '-V':
      print "OTP, version 0.0."
      sys.exit(0)
    elif opt == '--encrypt' or opt == '-e':
      encrypting = True
    elif opt == '--decrypt' or opt == '-d':
      decrypting = True
    elif opt == '--offset':
      offset = int(value)
    elif opt == '--config' or opt == '-C':
      config_area = value
    elif opt == '--debug':
      debug = 1
    else:
      sys.stderr.write("Error: unrecognized option: '%s'\n" % opt)
      sys.exit(1)

  if not encrypting and not decrypting:
    sys.stderr.write("Error: must pass either '-e' or '-d'.\n")
    sys.exit(1)

  if encrypting and decrypting:
    sys.stderr.write("Error: cannot pass both '-e' and '-d'.\n")
    sys.exit(1)

  if len(args) != 1:
    sys.stderr.write("%s\n" % usage())
    sys.exit(1)

  pad_file = args[0]
  pad = Pad(pad_file)

  config = Configuration(config_area)
  config.register(pad)

  ### todo: need to be less clumsy about offset handling
  if offset is not None:
    pad.set_offset(offset)

  # The first line of OTP format is the begin line.
  # Then comes the header: a group of lines followed by a blank line.
  # Then comes the encoded body.
  # The last line indicates the end, and is distinguishable from
  #   encoded content by inspection 
  otp_begin = "-----BEGIN OTP MESSAGE-----\n"
  otp_header = "%s" % otp_begin                \
               + "Version: OTP v0.0\n"         \
               + "Pad ID: %s\n" % pad.id()     \
               + "Offset: %s\n" % pad.offset() \
               + "\n"
  otp_end = "-----END OTP MESSAGE-----\n"

  if encrypting:
    encoder = PadEncoder(pad, config)
    sys.stdout.write(otp_header)
    while 1:
      str = sys.stdin.read()
      if len(str) > 0:
        result = encoder.encode(str)
        if result:
          sys.stdout.write(result)
      else:
        result = encoder.finish()
        if result:
          sys.stdout.write(result)
        break
    sys.stdout.write(otp_end)

  elif decrypting:
    decoder = PadDecoder(pad, config)
    saw_end = None
    maybe_header_line = sys.stdin.readline()
    if maybe_header_line != otp_begin:
      sys.stderr.write("Error: malformed OTP format: no begin line.\n")
      sys.exit(1)
    while maybe_header_line != "\n":
      maybe_header_line = sys.stdin.readline()
      m = re.match("Offset: ([0-9]+)", maybe_header_line)
      if m:
        pad.set_offset(int(m.group(1)))
    while 1:
      str = sys.stdin.readline()
      if str == otp_end:
        saw_end = 1
        break
      if len(str) > 0:
        try:
          result = decoder.decode(str)
        except EOFError:
          break
        if result:
          sys.stdout.write(result)
      else:
        break
    decoder.finish()
    if not saw_end:
      sys.stderr.write("Error: malformed OTP format: no end line.\n")
      sys.exit(1)

  if encrypting or decrypting:
    config.save()

  if debug:
    config.show_pads()

if __name__ == '__main__':
  main()

