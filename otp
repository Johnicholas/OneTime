#!/usr/bin/env python

# Encoder/decoder for one-time pads.  See usage() for details.

import os
import sys
import getopt
import bz2
import base64
import sha
import xml
import xml.dom
import xml.dom.minidom

class Pad:
  """An encoder/decoder associated with a specific pad at a specific offset.
  Feed bytes through convert() to XOR them against the pad."""
  def __init__(self, pad, offset):
    """Initialize a new pad, using padfile PAD at OFFSET.
    """
    self.offset = offset
    self.padfile = open(pad)
    self._length = 0  # number of pad bytes used
    self._id = self._get_id(self.padfile)
    self.padfile.seek(self.offset)
    
  def convert(self, str):
    """Return a new string that is STR XORed against the pad."""
    pad_str = self.padfile.read(len(str))
    result = ''
    for i in range(len(str)):
      result = result + chr(ord(str[i]) ^ ord(pad_str[i]))
    self._length += len(str)
    return result

  def _get_id(self, padfile):
    """Get the ID (the SHA1 of its first kilobyte) for this pad."""
    saved_posn = self.padfile.tell()
    self.padfile.seek(0)
    sha1 = sha.new()
    str = self.padfile.read(1024)
    sha1.update(str)
    self.padfile.seek(saved_posn)
    return sha1.hexdigest()

  def id(self):
    """Return the pad's ID."""
    return self._id

  def length(self):
    """Return the number of pad bytes used so far."""
    return self._length


class PadEncoder:
  """Class for encoding raw data to OTP output."""

  class PadEncoderNotFinished(Exception):
    """Exception raised if the encoder is asked for information it
    doesn't have yet, such as the final encoded length."""
    pass

  def __init__(self, pad):
    """Initialize an encoder for PAD."""
    self.pad = pad
    self.compressor = bz2.BZ2Compressor()
    self.finished = 0

  def _output(self, compressed_str):
    "Return encoding of COMPRESSED_STR, or None if COMPRESSED_STR is empty."
    if compressed_str:
      return base64.encodestring(compressed_str)
    else:
      return None

  def encode(self, str):
    """Return all available otp-encoded data so far, including for STR,
    or return None if no encoded data is ready yet."""
    return self._output(self.compressor.compress(self.pad.convert(str)))

  def finish(self):
    "Return last of encoding of COMPRESSED_STR, or None if none left."
    self.finished = 1
    return self._output(self.compressor.flush())

  def length(self):
    """Return the amount of pad data used by the encoding.  Calling this
    before finish() raises PadEncoderNotFinished."""
    if not self.finished:
      raise self.PadEncoderNotFinished
    return self.pad.length()


class PadDecoder:
  """todo: write this doc string"""
  def __init__(self, pad):
    """Initialize a decoder for PAD."""
    self.pad = pad
    self.decompressor = bz2.BZ2Decompressor()
    self.unused_data = ""

  def decode(self, str):
    """Return all available otp-decoded data so far, including for STR,
    or return None if no decoded data is ready yet.  Throw EOFError
    exception if called past the end of decodable data.  Store any
    unused data in self.unused_data."""
    return self.pad.convert((self.decompressor.decompress
                             (base64.decodestring(str))))


class Configuration:
  """A parsed representation of one user's ~/.otp/ configuration area.
  A .otp/ directory contains just a 'pads' file right now."""
  def __init__(self, path=None):
    """Initialize a new configuration.  If PATH is None, try to find
  the config area based on the runtime environment.  Otherwise, PATH
  should be a path to a .otp/ directory."""
    self.config_area = path
    if not self.config_area:
      self.config_area = "dot_otp"
    self.pads_file = os.path.join(self.config_area, "pads")
    self.pads = self._parse_pads()

  def _parse_pads(self):
    """Return a dictionary representing a 'pads' file (e.g., ~/.otp/pads).
    The dictionary is keyed on IDs, whose values are sub-dictionaries,
    whose keys are the remaining element names inside a pad, where the
    value of the 'used' element is a list of tuples, each tuple of the
    form (OFFSET, LENGTH).  So:

       dict[SHA1_SUM] ==> subdict
       subdict['path'] ==> PATH_VALUE
       subdict['used'] ==> [(OFFSET1, LENGTH1), (OFFSET2, LENGTH2), ...]

    A 'pads' file is an XML document like this:

      <?xml version="1.0" encode="UTF-8"?>
      <!DOCTYPE TYPE_OF_DOC SYSTEM/PUBLIC "dtd-name">
      <otp-pads>
         <pad>
           <id>SHA1_HASH_OF_FIRST_KILOBYTE_OF_PAD</id>
           <path>ABS_PATH_TO_PAD</path>
           <used><offset>OFFSET_A</offset>
                 <length>LENGTH_A</length></used>
           <used><offset>OFFSET_B</offset>
                 <length>LENGTH_B</length></used>
           ...
         </pad>
         <pad>
           <id>SHA1_HASH_OF_FIRST_KILOBYTE_OF_PAD</id>
           <path>ABS_PATH_TO_PAD</path>
           <used><offset>OFFSET_C</offset>
                 <length>LENGTH_C</length></used>
           ...
         </pad>
         ...
      </otp-pads>
      """
    dom = xml.dom.minidom.parse(self.pads_file)
    dict = { }

    for pad in dom.firstChild.childNodes:
      id = None
      path = None
      used = [ ]
      if pad.nodeType == xml.dom.Node.ELEMENT_NODE:
        for pad_part in pad.childNodes:
          if pad_part.nodeType == xml.dom.Node.ELEMENT_NODE:
            if pad_part.nodeName == "id":
              id = pad_part.childNodes[0].nodeValue
            elif pad_part.nodeName == "path":
              path = pad_part.childNodes[0].nodeValue
            elif pad_part.nodeName == "used":
              offset = None
              length = None
              for used_part in pad_part.childNodes:
                if used_part.nodeName == "offset":
                  offset = int(used_part.childNodes[0].nodeValue)
                if used_part.nodeName == "length":
                  length = int(used_part.childNodes[0].nodeValue)
              used.append((offset, length))
            else:
              ### todo: or error on unrecognized element?
              pass
        subdict = { }
        subdict["path"] = path
        subdict["used"] = used
        dict[id] = subdict

    return dict
    
  def save(self):
    """Save the pads file."""
    tempfile = self.pads_file + ".tmp"
    fp = open(tempfile, 'w')
    fp.write("<otp-pads>\n")
    for pad in self.pads.keys():
      fp.write("  <pad>\n")
      fp.write("    <id>%s</id>\n" % pad)
      fp.write("    <path>%s</path>\n" % self.pads[pad]["path"])
      ### todo: consolidate used tuples first
      for tuple in self.pads[pad]["used"]:
        fp.write("    <used><offset>%d</offset>\n" % tuple[0])
        fp.write("          <length>%d</length></used>\n" % tuple[1])
      fp.write("  </pad>\n")
    fp.write("</otp-pads>\n")
    os.rename(tempfile, self.pads_file)

  def show_pads(self):
    """Print pads configuration, presumably for debugging."""
    for pad in self.pads.keys():
      print "Pad %s:" % pad
      print "  path: \"%s\"" % self.pads[pad]["path"]
      print "  used:", self.pads[pad]["used"]


def usage():
  """Return a usage string."""
  return """Usage: otp [-e|-d] PAD_FILE PAD_OFFSET < INPUT > OUTPUT
         
Encoder/decoder for one-time pads.  Encoding and decoding are not
symmetrical, because otp compresses plaintext input to save pad.
Thus, otp needs to be told whether it is encoding or decoding."""


def main():
  # Exactly one of these two gets set to 1.
  encrypting = None
  decrypting = None

  # The first line of OTP format is the header.
  # The second through (N-1)th lines are the encoded body.
  # The last line is the footer.
  
  otp_header = "-----BEGIN OTP MESSAGE-----\n"
  #            + "Version: OTP v0.0\n"
  #            + "Pad ID: %s\n"
  #            + "Offset: %s\n"
  #            + "Length: %s\n"
  #            + "\n"
  
  otp_footer = "-----END OTP MESSAGE-----\n"

  try:
    opts, args = getopt.getopt(sys.argv[1:],
                               'edh?vVC:',
                               [ "encrypt", "decrypt",
                                 "config=",
                                 "debug",
                                 "help", "version"])
  except getopt.GetoptError, e:
    sys.stderr.write("Error: '%s'\n" % str(e))
    sys.exit(1)

  encrypting = None
  decrypting = None
  config_area = None
  debug = None

  for opt, value in opts:
    if opt == '--help' or opt == '-h' or opt == '-?':
      usage()
      sys.exit(0)
    elif opt == '--version' or opt == '-v' or opt == '-V':
      print "OTP, version 0.0."
      sys.exit(0)
    elif opt == '--encrypt' or opt == '-e':
      encrypting = 1
    elif opt == '--decrypt' or opt == '-d':
      decrypting = 1
    elif opt == '--config' or opt == '-C':
      config_area = value
    elif opt == '--debug':
      debug = 1
    else:
      sys.stderr.write("Error: unrecognized option: '%s'\n" % opt)
      sys.exit(1)

  if not config_area:
    ### todo: no, this should be user's ~/.otp/ directory, and
    ### make Configuration set it up if it doesn't exist.
    config_area = "."

  if not encrypting and not decrypting:
    sys.stderr.write("Error: must pass either '-e' or '-d'.\n")
    sys.exit(1)

  # Ignore opts for now, just encrypt.
  if len(args) != 2:
    sys.stderr.write("%s\n" % usage())
    sys.exit(1)

  config = Configuration(config_area)

  pad_file = args[0]
  pad_offset = int(args[1])
  pad = Pad(pad_file, pad_offset)

  if encrypting:
    encoder = PadEncoder(pad)
    sys.stdout.write(otp_header)
    while 1:
      str = sys.stdin.read()
      if len(str) > 0:
        result = encoder.encode(str)
        if result:
          sys.stdout.write(result)
      else:
        result = encoder.finish()
        if result:
          sys.stdout.write(result)
        break
    sys.stdout.write(otp_footer)

  elif decrypting:
    decoder = PadDecoder(pad)
    saw_header = None
    saw_footer = None
    while 1:
      maybe_header = sys.stdin.readline()
      if maybe_header == otp_header:
        saw_header = 1
        break
    if saw_header:
      while 1:
        str = sys.stdin.readline()
        if str == otp_footer:
          saw_footer = 1
          break
        if len(str) > 0:
          try:
            result = decoder.decode(str)
          except EOFError:
            break
          if result:
            sys.stdout.write(result)
        else:
          break
      if not saw_footer:
        sys.stderr.write("Error: malformed OTP format: no footer line.\n")
        sys.exit(1)
    else:
      sys.stderr.write("Error: no OTP header line found.\n")
      sys.exit(1)

  if encrypting or decrypting:
    config.save()

  if debug:
    config.show_pads()

if __name__ == '__main__':
  main()

