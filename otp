#!/usr/bin/env python

# Encoder/decoder for one-time pads.  See usage() for details.

import sys
import getopt
import bz2
import base64

class Pad:
  """An encoder/decoder associated with a specific pad at a specific offset.
  Feed bytes through convert() to XOR them against the pad."""
  def __init__(self, pad, offset):
    """Initialize a new pad, using padfile PAD at OFFSET.
    """
    self.orig_offset = offset
    self.cur_offset  = offset
    self.padfile = open(pad)
    self.padfile.seek(offset)
    
  def convert(self, str):
    """Return a new string that is STR XORed against the pad."""
    pad_str = self.padfile.read(len(str))
    result = ''
    for i in range(len(str)):
      result = result + chr(ord(str[i]) ^ ord(pad_str[i]))
    self.cur_offset += len(str)
    return result    


class PadEncoder:
  """Class for encoding raw data to OTP output."""
  def __init__(self, pad):
    """Initialize an encoder for PAD."""
    self.pad = pad
    self.compressor = bz2.BZ2Compressor()

  def _output(self, compressed_str):
    "Return encoding of COMPRESSED_STR, or None if COMPRESSED_STR is empty."
    if compressed_str:
      return base64.encodestring(compressed_str)
    else:
      return None

  def encode(self, str):
    """Return all available otp-encoded data so far, including for STR,
    or return None if no encoded data is ready yet."""
    return self._output(self.compressor.compress(self.pad.convert(str)))

  def finish(self):
    "Return last of encoding of COMPRESSED_STR, or None if none left."
    return self._output(self.compressor.flush())


class PadDecoder:
  """todo: write this doc string"""
  def __init__(self, pad):
    """Initialize a decoder for PAD."""
    self.pad = pad
    self.decompressor = bz2.BZ2Decompressor()
    self.unused_data = ""

  def decode(self, str):
    """Return all available otp-decoded data so far, including for STR,
    or return None if no decoded data is ready yet.  Throw EOFError
    exception if called past the end of decodable data.  Store any
    unused data in self.unused_data."""
    return self.pad.convert((self.decompressor.decompress
                             (base64.decodestring(str))))


def usage():
  """Return a usage string."""
  return """Usage: otp [-e|-d] PAD_FILE PAD_OFFSET < INPUT > OUTPUT
         
Encoder/decoder for one-time pads.  Encoding and decoding are not
symmetrical, because otp compresses plaintext input to save pad.
Thus, otp needs to be told whether it is encoding or decoding."""

def main():
  # Exactly one of these two gets set to 1.
  encrypting = None
  decrypting = None

  # The first line of OTP format is the header.
  # The second through (N-1)th lines are the encoded body.
  # The last line is the footer.
  otp_header = "--- OTP VERSION 1 ---\n"
  otp_footer = "--- OTP END ---\n"

  try:
    opts, args = getopt.getopt(sys.argv[1:],
                               'edh?vV',
                               [ "encrypt", "decrypt", "help", "version"])
  except getopt.GetoptError, e:
    sys.stderr.write("Error: '%s'\n" % str(e))
    sys.exit(1)

  for opt, value in opts:
    if opt == '--help' or opt == '-h' or opt == '-?':
      usage()
      sys.exit(0)
    elif opt == '--version' or opt == '-v' or opt == '-V':
      print "OTP, version 0.0."
      sys.exit(0)
    elif opt == '--encrypt' or opt == '-e':
      encrypting = 1
    elif opt == '--decrypt' or opt == '-d':
      decrypting = 1

  if not encrypting and not decrypting:
    sys.stderr.write("Error: must pass either '-e' or '-d'.\n")
    sys.exit(1)

  # Ignore opts for now, just encrypt.
  if len(args) != 2:
    sys.stderr.write("%s\n" % usage())
    sys.exit(1)

  pad_file = args[0]
  pad_offset = int(args[1])
  pad = Pad(pad_file, pad_offset)

  if encrypting:
    encoder = PadEncoder(pad)
    sys.stdout.write(otp_header)
    while 1:
      str = sys.stdin.read()
      if len(str) > 0:
        result = encoder.encode(str)
        if result:
          sys.stdout.write(result)
      else:
        result = encoder.finish()
        if result:
          sys.stdout.write(result)
        break
    sys.stdout.write(otp_footer)

  elif decrypting:
    decoder = PadDecoder(pad)
    saw_header = None
    saw_footer = None
    while 1:
      maybe_header = sys.stdin.readline()
      if maybe_header == otp_header:
        saw_header = 1
        break
    if saw_header:
      while 1:
        str = sys.stdin.readline()
        if str == otp_footer:
          saw_footer = 1
          break
        if len(str) > 0:
          try:
            result = decoder.decode(str)
          except EOFError:
            break
          if result:
            sys.stdout.write(result)
        else:
          break
      if not saw_footer:
        sys.stderr.write("Error: malformed OTP format: no footer line.\n")
        sys.exit(1)
    else:
      sys.stderr.write("Error: no OTP header line found.\n")
      sys.exit(1)
                       

if __name__ == '__main__':
  main()

