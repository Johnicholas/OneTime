#!/usr/bin/env python

__version__ = "2.0-beta10"

__doc__ = """OneTime: an open source encryption program that uses the one-time pad method.

(Run 'onetime --help' for usage information.)

The usual public-key encryption programs, such as GnuPG, are probably
secure for everyday purposes, but their implementations are too
complex for all but the most knowledgeable programmers to vet, and
in some cases there may be vulnerable steps in the supply chain
between their authors and the end user.  When bootstrapping trust,
it helps to start with something you can trust by inspection.

Hence this script, OneTime, a simple program that encrypts plaintexts
against one-time pads.  If you don't know what one-time pads are, this
program may not be right for you.  If you do know what they are and
how to use them, this program can make using them more convenient.

OneTime handles some of the pad-management bureaucracy for you.  It
avoids re-using pad data -- except when decrypting the same message
twice -- by maintaining records of pad usage in ~/.onetime/pad-records.
(The pads themselves are not typically stored there, just records
about pad usage.)

Recommended practice: if you are Alice communicating with Bob, then
keep two different pads, 'alice_to_bob.pad' and 'bob_to_alice.pad', as
opposed to sharing the same pad for both directions of communication.
With two separate pads, even if you each send a message simultaneously
to the other with no advance planning, you still won't accidentally
use any of the same pad data twice, assuming you let OneTime do its
bookkeeping naturally.

See http://en.wikipedia.org/wiki/One-time_pad for more information
about one-time pads in general.

OneTime is written by Karl Fogel and distributed under an MIT-style
open source license; run 'onetime --license' or see the LICENSE file
in the full distribution for complete licensing information.
OneTime's home page is http://www.red-bean.com/onetime/.
"""

import os
import sys
import stat
import getopt
import bz2
import base64
import hashlib
import re
import xml
import xml.dom
import xml.dom.minidom


########################### Design Overview #############################
# 
# To encrypt, OneTime first compresses input using bzip2, then XOR's
# the bzipped stream against the pad, and emits the result in base64
# encoding.  As it does so, it records in ~/.onetime/pad-records that
# that length of pad data, starting at a particular offset, has been
# used, so that the user won't ever re-use that stretch of pad for
# encryption again.
# 
# To decrypt, OneTime does the reverse: base64-decode the input, XOR
# it against the pad (starting at the pad offset specified in the
# encrypted message), and bunzip2 the result.  Decryption also records
# that this range has been used, in ~/.onetime/pad-records, because
# the recipient of a message should of course never use the same
# pad data to encrypt anything else.
#
# The output format looks like this:
#
#
#   -----BEGIN OneTime MESSAGE-----
#   Format: internal  << NOTE: OneTime 1.x and older cannot read this format. >>
#   Pad ID: [...64 hexadecimal digits of unique pad ID...]
#   Offset: [...a number expressed in decimal...]
#   
#   [...encrypted block, base64-encoded...]
#   
#   -----END OneTime MESSAGE-----
#
# The encrypted block has some structure, though -- it's not *just* a
# base64 encoding of pad-XOR'd bzipped plaintext data.  Before and
# after the core data, there's some bookkeeping, all base64-encoded.
# Here's a diagram, with offset increasing from left to right:
#
#   FFHHTT******----------------------------------------DDDDDDDD*******
#
# Here is what the different parts mean:
#
#   F  ==  a few format indicator bytes:
#
#          These tell OneTime what version of its internal format it
#          is looking at.  This is really just for future-proofing,
#          since these internal format indicator bytes were only
#          introduced in 2.0, and as of this writing OneTime is still
#          using that first format (known as "internal" format).
#
#   H  ==  a few head fuzz source length bytes:
# 
#          A few bytes of raw pad data, used to calculate
#          the number of bytes of head fuzz (the first 
#          set of asterisks) that will be used.
#
#   T  ==  a few tail fuzz source length bytes:
# 
#          A few more bytes of raw pad data, used to calculate
#          the number of bytes of tail fuzz (the concluding
#          set of asterisks) that will be used. 
#
#   *  ==  a random number of fuzz bytes (head or tail):
# 
#          A random number (derived from the pad -- see above) of raw
#          bytes taken from the pad.  The ones at the front are called
#          "head fuzz", and their presences means that an attacker
#          cannot know exactly where in the encrypted text the message
#          starts).  The ones at the end are "tail fuzz", and their
#          presence means that an attacker cannot know where the message
#          ends.  That is, the real message (and its digest, see below)
#          sits somewhere along a slider surrounded by fuzz on each
#          side, where the precise amount of fuzz on each side is known
#          only to those with the pad.  This prevents a known-plaintext
#          message substitution attack: because attackers cannot know
#          where the message is, they cannot reliably replace a known
#          plaintext with some other plaintext of the same length, even
#          if they have channel control.
# 
#   -  ==  the actual encrypted plaintext
# 
#          Base64-encoded XOR'd bzipped plaintext.
#
#   D  ==  32 bytes of message digest
#
#          A SHA256 hash, XOR'd with pad, of the original plaintext.
#          Note this is not a hexadecimal representation of the hash;
#          to save space, it is the raw hash digest.  However, any
#          message integrity errors display the hash in hexadecimal.
#
# On decryption, OneTime not only verifies the message digest, but
# also that the head fuzz and tail fuzz exactly match the expected
# pad bytes (those bytes were not used for encryption of course; they
# were used *only* for fuzz).  If anything doesn't match, OneTime will
# raise an error -- though if the error was detected only in the
# digest or in the tail fuzz, then there may still have been a
# successful decryption first, with plaintext output emitted.
# 
########################################################################

# The current format level.
#
# Some background is needed to understand what this means:
#
# The first releases of OneTime (the 1.x series) did not include any
# indication of the format in the plaintext headers of the output.
# This was deliberate: after all, if there *were* a format change in
# the future, a "Format:" header could be added, and its presence
# would indicate that the output was clearly from a later version than
# the 1.x series.
#
# Well, that has now happened -- but instead of specifying an exact
# format version in the plaintext header, we just specify that the
# format is "internal", and in the code we call that a "format level"
# instead of a "format version".  We distinguish between this new
# "internal" level and the old level (now retroactively labeled
# "original"), for the purpose of supporting OneTime 1.x and earlier,
# but beyond that the plaintext header does not say anything about the
# format other than that label "internal".
#
# There are a couple of reasons to do it this way.  One, to get away
# from the idea that the version of OneTime is relevant, since that
# what really matters is just the output format -- which can and often
# will remain unchanged, or at least backward-compatible, from version
# to version of OneTime.  Two, starting from OneTime 2.0, all detailed
# format version information is embedded in "inner headers" in the
# ciphertext (see the PadSession class for details), not in the plaintext
# headers.  This avoids leaking information about the earliest
# possible date on which the message could have been encrypted,
# because the ciphertext will reveal only that the message must have
# been encrypted with OneTime 2.0 or higher.
#
# Therefore, in OneTime's code, instead of using numbers for the
# format level, we use one of two words: "internal" or "original".
#
# Note also that the "original" format had a (rather embarrassing) bug
# whereby plaintext was encrypted and then compressed, instead of the
# other way around.  This is fixed in all the "internal" level
# formats, and of course any further format details are now embedded
# in the inner headers in the cipthertext, as described in class PadSession.
Format_Level = "internal"

class PadSession:
  """An encoder/decoder associated with a specific pad at a specific offset.
Feed bytes through convert() to XOR them against the pad.

A PadSession is used for a single encryption or decryption session; it should
not be used for subsequent sessions -- instead, a new PadSession object
should be generated (it might refer to the same underlying pad file,
but it still needs to be a new object due to certain initializations).
  """

  # Length of the front stretch of pad used for the ID.  The actual ID
  # is a SHA-256 sum of those bytes, which are themselves then never
  # used for encryption.  (Why not just use a hex digest of the pad
  # bytes themselves?  There's no theoretical reason not to, but as a
  # sop to tradition, and to avoid the distraction of explaining why
  # using raw pad would be okay, we just use the SHA-256 sum instead.)
  _id_source_length = 32

  # The plaintext is authenticated with a SHA256 hash digest that
  # is itself encrypted with the pad and included in the ciphertext.
  _digest_length = 32

  def __init__(self, pad_path):
    """Initialize a new pad session, using padfile PAD_PATH.  The pad session
    cannot be used for encoding or decoding until set_offset() is called."""
    self.pad_path = pad_path
    self.padfile = open(self.pad_path, "rb")
    self.pad_size = os.stat(self.pad_path)[stat.ST_SIZE]
    self._offset = None  # where to start using pad bytes (must initialize)
    self._length = 0  # number of pad bytes used this time
    self._default_fuzz_source_length = 2   # See _make_fuzz_length_from_pad()
    self._default_fuzz_source_modulo = 512 # and see _make_inner_header().

    # These are just caches for self.id(), which see.
    self._id = None
    self._original_format_level_id = None

    # If this encoding/decoding session saw a particular format level,
    # record it so we can check that it remains consistent.
    self._format_level = None

    # On decoding, a given call to convert() might not supply enough
    # string to use up the inner headers.  Therefore we must remember
    # how much of the head_fuzz still needs to be used up.
    self._pad_remaining_to_skip = 0

    # There are both head and tail fuzz, but we only need to remember
    # the tail fuzz length (and the raw bytes used to compute it),
    # because we learn the length at the start of processing but wait
    # till the end to use it, whereas the head fuzz we emit as soon as
    # we learn its length.
    self._tail_fuzz_length = None
    self._tail_fuzz_length_source_bytes = None

    # This buffer always holds the latest input, and must always be at
    # least as long as the tail digest + tail fuzz, so that we can
    # refrain from decrypting them as part of the original plaintext.
    self._tail_buffer = ''

    # Most of what a pad session does is the same for encoding and decoding --
    # after all, the conversion step is XOR, which is symmetrical.
    #
    # However, before conversion can happen, the pad session needs to know
    # whether to write or read the inner header flag bytes -- so for
    # that it needs to know whether it's encoding or decoding.  When
    # that step is done, the appropriate variable below is set;
    # exactly one of them *must* be set before any conversion happens.
    self._encoding = False
    self._decoding = False
    # False until conversion starts, True thereafter.  (Conversion
    # starts after all the head fuzz has been verified.)
    self._begun = False
    
  class PadSessionUninitialized(Exception):
    """Exception raised if PadSession hasn't been initialized yet."""
    pass

  class OverPrepared(Exception):
    """Exception raised if a PadSession is initialized or prepared twice."""
    pass

  class PadShort(Exception):
    """Exception raised if pad doesn't have enough data for this encryption."""
    pass

  class FormatLevel(Exception):
    """Exception raised for an unknown or inconsistent format level."""
    pass

  class InnerFormat(Exception):
    """Exception raised if something is wrong with the inner format."""
    pass

  class FuzzMismatch(Exception):
    """Exception raised if pad and input fuzz don't match."""
    pass

  def prepare_for_encoding(self):
    """Mark this PadSession as encoding.  This or prepare_for_decoding() must
    be called exactly once, before any conversion happens."""
    if self._encoding:
      raise PadSession.OverPrepared("already prepared for encoding")
    if self._decoding:
      raise PadSession.OverPrepared(
        "cannot prepare for both encoding and decoding")
    self._encoding = True

  def prepare_for_decoding(self):
    """Mark this PadSession as decoding.  This or prepare_for_encoding() must
    be called exactly once, before any conversion happens."""
    if self._decoding:
      raise PadSession.OverPrepared("already prepared for decoding")
    if self._encoding:
      raise PadSession.OverPrepared(
        "cannot prepare for both decoding and encoding")
    self._decoding = True

  def set_offset(self, offset):
    """Set this pad session's encoding/decoding offset to OFFSET."""
    if offset >= self.pad_size:
      raise PadSession.PadShort("offset exceeds pad size, need more pad")
    self._offset = offset
    self.padfile.seek(self._offset)

  def convert(self, string, format_level="internal"):
    """If STRING is not empty or None, return it as XORed against the pad;
else return the empty string.  Note STRING may be empty on intermediate
calls simply because a compressor has not yet had enough incoming data to
work with, not necessarily because input is ended yet.

If FORMAT_LEVEL is "original", then don't handle the head and tail 
used by the later format levels.  Otherwise, do handle the head and
tail: for the head, skip over the fuzz; for the tail, just remember
its length so we can handle it later.

It is an error to call this multiple times with different FORMAT_LEVEL
values, for a given PadSession instance.  Whatever you pass the first time
must be used for all subsequent calls with that instance.

    """
    result = ''
    if self._offset is None:
      raise PadSession.PadSessionUninitialized(
        "pad session not yet initialized (no offset)")
    if self._format_level is None:
      self._format_level = format_level
    elif self._format_level != format_level:
      raise PadSession.FormatLevel(
        "inconsistent format levels requested: '%s' and '%s'"
        % (self._format_level, format_level))
    if format_level == "internal":
      if self._encoding and self._decoding:
        raise PadSession.OverPrepared(
          "pad session cannot encode and decode simultaneously")
      elif not self._encoding and not self._decoding:
        raise PadSession.PadSessionUninitialized(
          "pad session not yet prepared for either encoding or decoding")
      elif not self._begun:
        if self._encoding:
          inner_header_data = self._make_inner_header()
          result += inner_header_data
        else: # self._decoding is set
          # TODO (minor): It's possible string might be so short that
          # it doesn't even contain enough information to know the fuzz
          # length yet.  The solution is easy: if we haven't yet begun,
          # then just accumulate string to prepend to the next call(s),
          # until a call comes when we have enough to work with.
          #
          # This is not an urgent problem, as in practice no I/O system
          # is likely to deliver string in chunks so small.  So, saving
          # it to solve later.
          string, pad_remaining = self._handle_inner_header(string)
          if string != "" and pad_remaining != 0:
            raise PadSession.InnerFormat(
              "Got both a result string and a pad remainder")
          if pad_remaining > 0:
            self._pad_remaining_to_skip = pad_remaining
      if self._pad_remaining_to_skip > 0:
        new_pad_remaining = 0
        bytes_to_verify_now = 0
        if self._pad_remaining_to_skip > len(string):
          new_pad_remaining = self._pad_remaining_to_skip - len(string)
          num_bytes_to_verify_now = len(string)
        else:
          num_bytes_to_verify_now = self._pad_remaining_to_skip
        self._pad_remaining_to_skip = new_pad_remaining
        bytes_unverified, string = self._verify_fuzz_bytes(num_bytes_to_verify_now, string)
        self._pad_remaining_to_skip += bytes_unverified

      # Once we've handled any inner headers, buffer for decoding.
      if self._decoding:
        self._tail_buffer += string
        # Reserve exactly the tail length each time, so that on the
        # last iteration we can just verify both parts of the tail
        # (the digest and the fuzz) without emitting new output.
        if len(self._tail_buffer) < (PadSession._digest_length + self._tail_fuzz_length):
          string = ''   # wait until we have more or are done
        else:
          string = self._tail_buffer[:(0 - (PadSession._digest_length + self._tail_fuzz_length))]
          self._tail_buffer = self._tail_buffer[
            (0 - (PadSession._digest_length + self._tail_fuzz_length)):]

    string_len = len(string)
    pad_str = self.padfile.read(string_len)
    if len(pad_str) < string_len:
      raise PadSession.PadShort(
        "not enough pad data available to finish encryption")
    for i in range(string_len):
      result += chr(ord(string[i]) ^ ord(pad_str[i]))
    self._length += string_len
    self._begun = True
    return result


  def _get_id(self):
    """Get the ID for this session's underlying pad.
    (The ID is just the pad's first 32 bytes in hexadecimal.)"""
    # There's no harm in exposing this data in a pad-records file.
    # The ID portion of the pad is never used for encryption, and we
    # expose other non-encrypting pad portions in the head fuzz and
    # tail fuzz in the message anyway.  If the pad is truly random,
    # this is all fine; if it's not random, all bets are off.
    saved_posn = self.padfile.tell()
    self.padfile.seek(0)
    string = self.padfile.read(PadSession._id_source_length)
    self.padfile.seek(saved_posn)
    return string.encode('hex')

  def _get_original_format_level_id(self):
    """Get the OneTime \"original\" format level ID for the session pad.
    In that format level, pad IDs were based on the first 1024
    (octet) bytes of the pad.  This was needlessly spendy, or rather,
    it would have been needlessly spendy if OneTime 1.x had been
    paranoid enough to not use any of those bytes for encryption.
    Version 2.0 fixed this, reducing the number of bytes used on ID but
    also making they are not used for encryption."""
    saved_posn = self.padfile.tell()
    self.padfile.seek(0)
    sha1 = hashlib.sha1()
    string = self.padfile.read(1024)
    sha1.update(string)
    self.padfile.seek(saved_posn)
    return sha1.hexdigest()

  def id(self, format_level="internal"):
    """Return the pad ID of the pad belonging to this pad session.
    If FORMAT_LEVEL is specified, return ID according to that format level."""
    if format_level == "internal":
      if self._id is None:
        self._id = self._get_id()
      return self._id
    elif format_level == "original":
      if self._original_format_level_id is None:
        self._original_format_level_id = self._get_original_format_level_id()
      return self._original_format_level_id
    else:
      raise PadSession.FormatLevel("unknown format \"%s\" for ID"
                                   % format_level)

  def path(self):
    """Return the pad's path."""
    return self.pad_path

  def offset(self):
    """Return offset from which encoding/decoding starts."""
    return self._offset

  def length(self):
    """Return the number of pad bytes used so far."""
    return self._length

  def _make_fuzz_length_from_pad(self, num_bytes, modulo):
    """Calculate a fuzz skip length based on the next NUM_BYTES bytes % MODULO,
    advancing the pad accordingly.  Return that length and the raw pad
    data used to calculate it in a tuple of the form:

      [calculated_length, source_bytes]
    """
    # What's going on here?  What is "fuzz"?
    #
    # "Fuzz" is a distance we skip forward in the pad.  If the skip
    # happens before any pad data is used for encryption or
    # decryption, it is "head fuzz"; if the skip happens after all
    # encryption or decryption is done, it is "tail fuzz".  Because
    # the distance to skip is based on data in the pad, it can only be
    # known by those who have the pad.
    #
    # (Note that the tail of a OneTime message is actually two parts:
    # the encrypted message digest followed by the tail fuzz.)
    #
    # For both head fuzz and the tail fuzz, the distance skipped may
    # be determined in two ways:
    #
    #   1) Read NUM_BYTES from the current location in the pad, and
    #      use those bytes to calculate (in some deterministic way)
    #      the fuzz distance to skip.
    #
    #   2) Read a sender-specified distance that is encrypted in the
    #      pad right here ("here" being right after the inner header
    #      bytes), and then skip that distance.
    #
    # Right now we only use method (1), but support for method (2) is
    # built into the inner header format; see _make_inner_header().
    #
    # Here's how method (1) works:
    #
    # First we read NUM_BYTES bytes from the pad (the bytes are
    # consumed -- they won't be used for encoding data, and therefore
    # this happens before any pad gets used for encoding/decoding).
    #
    # We then portably convert that sequence of bytes to a number
    # modulo MODULO.  The result is the number of bytes forward to
    # skip in the pad before starting to consume pad data for use by
    # convert() in encoding or decoding.
    #
    # See _make_inner_header() for why we do things this way.
    fuzz_length_source = self.padfile.read(num_bytes)
    self._length += num_bytes
    if len(fuzz_length_source) < num_bytes:
      raise PadSession.PadShort(
        "not enough pad available to supply fuzz length source bytes")
    fuzz_skip_len = 1
    for x in fuzz_length_source:
      # We don't use int.from_bytes(), as it's only available in
      # Python >= 3.2.  Instead, we just multiply the bytes together
      # (as eight-bit values) and take the modulo of that.  It would
      # be more space-efficient to convert multiple bytes together as
      # a word-sized number of some kind, but that's harder to do
      # portably, and this has to work everywhere consistently.
      #
      # Since the current modulo is 512 and the default fuzz source
      # length is 2, we could have just done
      #
      #   sum([ord(x) for x in fuzz_length_source]) % 512
      #
      # But we may want to increase modulo and/or default fuzz source
      # length later; multiplying all the bytes together is as
      # efficient as we can be while maintaining portability.
      fuzz_skip_len *= ord(x)
    return [fuzz_skip_len % modulo, fuzz_length_source]

  def _verify_fuzz_bytes(self, num_bytes, string):
    """Verify that the next NUM_BYTES in this session's pad match STRING
    (a window of source material that starts with fuzz, but may
    continue on into non-fuzz.)  If STRING is shorter than NUM_BYTES,
    verify as much as possible.

    Return a tuple of [num_bytes_remaining, string_remaining].  (When all
    fuzz has been verified, the first element in that tuple will be 0.)

    If there is any mismatch between the pad and STRING, raise a
    FuzzMismatch exception."""
    try:
      # The max amount we can actually verify in this call.
      verifiable_len = min(len(string), num_bytes)
      pad_material = self.padfile.read(verifiable_len)
      self._length += verifiable_len
      if string[:verifiable_len] != pad_material[:verifiable_len]:
        raise PadSession.FuzzMismatch("expected fuzz does not match message fuzz")
      num_bytes_remaining = max(0, num_bytes - len(string))
      return [num_bytes_remaining, string[verifiable_len:]]
    except EOFError:
      raise PadSession.PadShort("not enough pad available to supply fuzz")

  def _get_pad_bytes(self, num_bytes):
    """Return NUM_BYTES worth of raw pad data, advancing the pad."""
    data = None
    try:
      data = self.padfile.read(num_bytes)
      self._length += num_bytes
    except EOFError:
      raise PadSession.PadShort("not enough pad available to supply raw data")
    return data

  def _make_inner_header(self):
    """Return inner header data to be encoded in the output.
    This must happen before any conversion of plaintext to ciphertext
    is done, so it must be called after the PadSession has been initialized
    but before self.convert() has consumed any pad for actual conversion."""
    inner_header = ''
    if self._offset is None:
      raise PadSession.PadSessionUninitialized(
        "pad session not yet initialized (no offset)")
    # We first jump to the offset specified by the plaintext headers.
    # 
    # Then we generate the inner header bytes: a series of bytes
    # that indicate various things about the encryption of the plaintext.  
    # The inner header bytes are themselves encrypted against the pad,
    # or (for the portion of the inner headers comprising the fuzz) are
    # made of raw pad data, so for each byte of inner header we have
    # to consume a byte of pad.
    #
    # The (plaintext) format of the inner headers is given below.
    # Some bytes are flag bytes, where each bit gives flags for
    # various options.  Depending on what those flags say, some of
    # the subsequent bytes indicate length or have other meanings.
    #
    #   BYTE 1:
    #     The first byte indicates the internal format version --
    #     think of it as the "x" in "internal.x", where "internal"
    #     comes from the plaintext "Format:" header.  Values 0-127 are
    #     interpreted as numbers; values > 128 mean combine this byte
    #     with the next byte (recursively, big endian).  The internal
    #     format version will probably never get that high, of course,
    #     but if it does, we're prepared :-).
    # 
    #   BYTE 2:
    #     In internal format 0, the second byte holds flag bits:
    # 
    #       0b_______*: 0 means use the default fuzz length
    #                   1 means next byte(s) hold sender-chosen fuzz length
    #       0b______*_: reserved; must be 0 in internal format 0
    #       0b_____*__: reserved; must be 0 in internal format 0
    #       0b____*___: reserved; must be 0 in internal format 0
    #       0b___*____: reserved; must be 0 in internal format 0
    #       0b__*_____: reserved; must be 0 in internal format 0
    #       0b_*______: reserved; must be 0 in internal format 0
    #       0b*_______: reserved; must be 0 in internal format 0
    # 
    #     If the first bit were set, then the next byte would indicate
    #     something about the fuzz length.  That might either be a
    #     sender-chosen definite length (still masked by the pad of
    #     course), or a length partly determined by the pad (similarly
    #     to the current code below) but with a sender-chosen minimum.
    #     That's all TBD: we don't support internal format 1 yet, only
    #     0, and in 0 the fuzz lengths come entirely from pad data.
    # 
    #     The meanings of the rest of the flag bits are not yet
    #     determined, and their values must be zero in format 2.0.
    #     (The value of the first bit must be zero right now, too,
    #     since sender-chosen lengths are not yet implemented, but at
    #     least we know more or less what that bit means already.)
    next_pad_byte = ord(self.padfile.read(1))
    self._length += 1
    # First byte is inner format version (currently 0):
    inner_header_format_version = 0 ^ next_pad_byte
    next_pad_byte = ord(self.padfile.read(1))
    self._length += 1
    # Next byte indicates how to determine fuzz_source length:
    fuzz_source_length_indicator = 0 ^ next_pad_byte
    # Now that we've taken care of the start of the header, we can
    # figure out how far to skip in the pad to make head fuzz, and
    # then do the skip.
    #
    # You may be wondering, why do we do a fuzz skip at all?
    #
    # There's a known-plaintext message authentication attack whereby
    # if the attacker knows the exact plaintext sent, and can actively
    # intercept messages, she could substitute some other plaintext
    # for it (since the relevant pad data could be derived).
    #
    # By prepending and appending random amounts of pad data (the
    # head fuzz distance and tail fuzz distance), we make it
    # impossible for the attacker to know exactly *where* the real
    # encrypted text starts and ends, which means she can't derive the
    # relevant part of the pad, so she can't substitute another
    # plaintext.
    #
    # Okay, but why not instead use a few bytes of pad data as a key
    # by which to encrypt the plaintext input with some standard block
    # cipher and then encode the result of *that* against the pad?
    # Wouldn't that protect against a known-plaintext attack better?
    #
    # True, but the problem with doing full symmetric encryption
    # "underneath" the pad is that there isn't any library for that in
    # the standard Python distribution.  Using only stuff available in
    # core Python is a design goal, to make distribution easier.
    # Also, adding a pad-keyed block-cipher would make the code more
    # complex and thus maintenance and debugging harder; simplicity
    # and inspectability are important goals for OneTime.
    #
    # Skipping "random" distances -- that is, distances known only
    # to those with the pad -- is portable and simple.  It also
    # disguises the length of the compressed plaintext a bit.  (We
    # can't afford to disguise it by very much, because we don't want
    # to use up a lot of pad by skipping very far; pad isn't cheap.)
    #
    # Hence, self._default_fuzz_source_modulo is currently 512.  We
    # will read two bytes two determine the head fuzz distance (i.e.,
    # the head skip distance will be 0 <= N <= 511), and read the
    # next two bytes to determine the tail fuzz distance (ditto).
    #
    # Now the attacker can't reliably substitute some other plaintext
    # for the original: she'd have only a 1-in-512 chance of guessing
    # the right distance for the head fuzz.  Even if she knows the
    # exact plaintext, she doesn't know where in the ciphertext the
    # compressed plaintext starts -- and the tail fuzz distance means
    # she can't just count backwards from the end of the ciphertext.
    # Thus a plaintext-substitution attack is prevented.
    #
    # It's tempting to set a higher modulus than 512, but given the
    # rate at which I at least can generate new pad data, that feels
    # too costly.  512 feels like the right point in the tradeoff
    # slider.  If anyone has data to support a different number, I
    # hope they'll speak up.  With self._default_fuzz_source_length at
    # two bytes, we could go all the way up to 65535, so most of this
    # code can stay the same if we later decide to expand the range.
    # (There's no particular reason the modulus has to be a power of
    # two, either, other than good taste.)
    #
    # These precautions greatly reduce the effectiveness of the
    # known-plaintext message authentication attack.  Still, even now
    # if you were to send the same message to, say, 1024 people who are
    # all using the same pad, and that exact plaintext were known to
    # the attacker, and the attacker were to have active intercept
    # capability with the recipients, then for some small number of
    # those recipients, the attacker could substitute some other
    # forged message in place of your original plaintext.  But the
    # attacker wouldn't know which subsitutions were successful, and
    # the rest of the recipients would receive an obviously garbage
    # message.  Given the number of prerequisites there, and the
    # unavoidable & easily detectable failure mode for the attacker,
    # this does not seem like a serious weakness to me, but comments
    # always welcome of course.
    #
    # Remember that the 512 should not be thought of as a key length.
    # The number of possibilities here is 1-in-512, not 1-in-(2^512).
    #
    # A possible improvement would be to skip by bits instead of
    # bytes, so we get 8 times the variability for the amount of pad
    # used up.  But skipping by bits would complicate the code, since
    # all the seeking and I/O is natively aligned on 8-bit boundaries.
    head_fuzz_length, head_fuzz_length_source_bytes = self._make_fuzz_length_from_pad(
      self._default_fuzz_source_length, self._default_fuzz_source_modulo)
    self._tail_fuzz_length, self._tail_fuzz_length_source_bytes = self._make_fuzz_length_from_pad(
      self._default_fuzz_source_length, self._default_fuzz_source_modulo)
    head_fuzz = self._get_pad_bytes(head_fuzz_length)
    result = chr(inner_header_format_version)       \
             + chr(fuzz_source_length_indicator)    \
             + head_fuzz_length_source_bytes        \
             + self._tail_fuzz_length_source_bytes  \
             + head_fuzz
    return result

  def _handle_inner_header(self, string):
    """Handle inner header data at front of STRING.
    Return remainder of STRING or the length of pad material left to
    skip (if STRING is shorter than the inner headers), as a tuple:

      [string_remainder_if_any, pad_length_left_to_skip_if_any]

    These two elements mutually exclude: if the string remainder is
    not the empty string, then the pad remainder length must be 0;
    else the pad remainder length must be an integer > 0 and the
    string remainder must be the empty string.

    This all must happen before any conversion of ciphertext to plaintext
    is done, so it must be called after the PadSession has been initialized
    but before self.convert() has consumed any pad for actual conversion.

    """
    # See self._make_inner_header() for inner header documentation.
    inner_format_version = None
    length_to_skip = 0
    if self._offset is None:
      raise PadSession.PadSessionUninitialized(
        "pad session not yet initialized (no offset)")
    next_pad_byte = ord(self.padfile.read(1))
    self._length += 1
    length_to_skip += 1
    pad_encoded_byte = ord(string[0])
    inner_format_version = pad_encoded_byte ^ next_pad_byte
    if inner_format_version == 0:
      first_flag_byte = ord(string[1]) ^ ord(self.padfile.read(1))
      self._length += 1
      length_to_skip += 1
      if first_flag_byte & 1 == 0:
        head_fuzz_length, head_fuzz_length_source_bytes = self._make_fuzz_length_from_pad(
          self._default_fuzz_source_length, self._default_fuzz_source_modulo)
        self._tail_fuzz_length, self._tail_fuzz_length_source_bytes = self._make_fuzz_length_from_pad(
          self._default_fuzz_source_length, self._default_fuzz_source_modulo)
        num_bytes_remaining, head_fuzz_remaining = self._verify_fuzz_bytes(
          head_fuzz_length, string[2 + (self._default_fuzz_source_length * 2):])
        length_to_skip += (self._default_fuzz_source_length * 2) + head_fuzz_length
      else:
        raise PadSession.InnerFormat(
          "cannot yet handle custom fuzz_source length")
      # Enforce the fact that we don't use any of the other flag bits yet.
      if (   first_flag_byte &   2 != 0
          or first_flag_byte &   4 != 0
          or first_flag_byte &   8 != 0
          or first_flag_byte &  16 != 0
          or first_flag_byte &  32 != 0
          or first_flag_byte &  64 != 0
          or first_flag_byte & 128 != 0):
        raise PadSession.InnerFormat(
          "first flag byte has unknown flags set (%s)"
          % bin(first_flag_byte))
    else:
      raise PadSession.InnerFormat("unknown inner format version \"%d\""
                            % inner_format_version)
    amount_left_to_skip = 0;
    if len(string) < length_to_skip:
      amount_left_to_skip = length_to_skip - len(string);
      return ["", amount_left_to_skip];
    else:
      return [string[length_to_skip:], 0]

  def _verify_digest(self, msg_hash):
    """Verify that the message digest encoded at the current location
    in the pad matches MSG_HASH, consuming PadSession._digest_length
    bytes of pad in the process.  If the digests do not match, raise a
    PadSession.FuzzMismatch error showing the two digests in hex form."""
    msg_digest = msg_hash.digest()
    pad_bytes = self.padfile.read(PadSession._digest_length)
    self._length += PadSession._digest_length
    found_digest = ''
    for i in range(PadSession._digest_length):
      found_digest += chr(ord(self._tail_buffer[i]) ^ ord(pad_bytes[i]))
    if msg_digest != found_digest:
      raise PadSession.FuzzMismatch("message digest mismatch:\n  expected: %s\n     found: %s\n"
                                    % (msg_hash.hexdigest(), found_digest.encode('hex')))

  def finish(self, msg_hash):
    """Close out this pad session, emitting or verifying MSG_HASH.
    If encrypting, return the pad-encrypted digest of MSG_HASH and the
    tail fuzz, as a single string.  If decrypting, verify that
    MSG_HASH matches the expected final hash for the plaintext
    message, and raise a PadSession.FuzzMismatch error if they do not
    match.  (If they do match, the return value is undefined and
    should be ignored.)"""
    if self._format_level == "internal":
      if self._tail_fuzz_length is None:
        raise PadSession.PadSessionUninitialized(
          "tail fuzz length never initialized")
      elif self._encoding:
        remainder = self.convert(msg_hash.digest())
        remainder += self.convert(u'\u0000' * self._tail_fuzz_length)
        return remainder
      elif self._decoding:
        # Decryption has already succeeded by the time we encounter
        # the tail, but if the tail doesn't match, we should still let
        # the user know the message was tampered with.
        #
        # There are two ways the tail could fail to match: either a
        # message digest mismatch (i.e., a message authentication
        # failure) against the first PadSession._digest_length bytes of
        # the tail, or a mismatch against the expected tail fuzz bytes.
        # 
        # Note that verifying the tail has the important side effect
        # of recording that last bit of pad usage on decryption, which
        # is important for avoiding pad re-use -- that's the bug for
        # which a test was added in commit 9e8422f07.
        self._verify_digest(msg_hash)
        bytes_remaining, str_remaining = self._verify_fuzz_bytes(
          self._tail_fuzz_length, self._tail_buffer[PadSession._digest_length:])
        if bytes_remaining != 0 or str_remaining != '':
          raise PadSession.FuzzMismatch("some source tail fuzz left over")
      else:
        raise PadSession.OverPrepared(
          "pad session out of whack: both encoding and decoding")

  def __str__(self):
    """Return a string representation of this pad session."""
    return "PadSession '%s' (%s):\n   Offset: %d\n   Length: %d\n" \
           % (self.path(), self.id(), self.offset(), self.length())

class PadSessionEncoder:
  """Class for encoding raw data to OneTime output."""

  class UnknownCompressionException(Exception):
    """Exception raised when an unknown compression method is requested."""
    pass

  def __init__(self, pad_sess, config):
    """Initialize an encoder for PAD_SESS with Configuration CONFIG."""
    self.pad_sess = pad_sess
    self.config = config
    # We use bz2 compression unconditionally.  If we offered a choice,
    # we'd have to name that choice somewhere for use in decryption.
    # But if we were to list the choice in the open headers, then we
    # would reveal something about the plaintext.  So we'd list it in
    # the inner headers, which would be fine, but it complicates the
    # code for no convincing reason: bz2 compression applied to
    # something non-compressible is more or less a no-op, give or take
    # a few bytes here and there.  Part of the point of this program
    # to be so simple as to be trivially auditable.  So we just use
    # bz2 unconditionally; the worst case is ok.
    self.compressor = bz2.BZ2Compressor()
    self.pad_sess.prepare_for_encoding()
    # Keep a running hash of the plaintext as we encrypt.
    self.msg_hash = hashlib.sha256()

  def encode(self, string):
    """Return onetime-encoded data for STRING, or the empty string if none.
    Consume pad as needed."""
    out = ''
    self.msg_hash.update(string)
    compressed_plaintext = self.compressor.compress(string)
    if len(compressed_plaintext) > 0:
      out = base64.encodestring(self.pad_sess.convert(compressed_plaintext))
    return out

  def finish(self):
    "Return last remaining bits of ciphertext, or None if none left."
    remainder = self.pad_sess.convert(self.compressor.flush())
    remainder += self.pad_sess.finish(self.msg_hash)
    remainder = base64.encodestring(remainder)
    self.config.record_consumed(self.pad_sess, False)
    return remainder


class PadSessionDecoder:
  """Class for decoding OneTime output back to plaintext."""

  class DecodingError(Exception):
    """Exception raised when something goes wrong decoding."""
    pass

  def __init__(self, pad_sess, config, format_level):
    """Initialize a decoder for PAD_SESS with Configuration CONFIG.
    FORMAT_LEVEL indicates the OneTime format level of the incoming
    data, i.e., the value given in the output's "Format:" header."""
    self.pad_sess = pad_sess
    self.config = config
    self.unused_data = ""
    self.format_level = format_level
    self.decompressor = bz2.BZ2Decompressor()
    # We keep a running hash of the plaintext as we decrypt.
    self.msg_hash = hashlib.sha256()

    if self.format_level != "original" and self.format_level != "internal":
      raise PadSession.FormatLevel(
        "impossible format level: \"%s\"" % self.format_level)
    self.pad_sess.prepare_for_decoding()

  def decode(self, string):
    """Return all available unreturned onetime-decoded data so far,
    including for STRING, or return None if no decoded data is ready yet.  
    Throw IOError if data is not decodable.  Throw EOFError exception
    if called past the end of decodable data.  Store any unused data
    in self.unused_data."""
    ret = ""
    if self.format_level == "original":
      # Format level "original" got the compression/encryption order
      # wrong.  Look, this is embarrassing.  I'm only telling you
      # about it because we still need to support that mis-ordering
      # for compatibility.
      ret = self.pad_sess.convert((self.decompressor.decompress(
      base64.b64decode(string))), format_level="original")
    else: # must be format level "internal"
      ret = self.decompressor.decompress(self.pad_sess.convert(
        base64.b64decode(string)))
    self.unused_data += self.decompressor.unused_data
    self.msg_hash.update(ret)
    return ret

  def finalize(self):
    """Finalize this session's pad usage with the configuration."""
    self.pad_sess.finish(self.msg_hash)
    self.config.record_consumed(self.pad_sess, True)


class Configuration:
  """A parsed representation of one user's ~/.onetime/ configuration area.
  A .onetime/ directory contains just a 'pad-records' file right now.

  Even in cases where we're operating without touching permanent
  storage, a Configuration instance is still created and updated
  internally.  This is partly because the Configuration does some
  consistency checks on incoming/outgoing data, and partly because it
  would be useful if we're ever providing an API.
  """

  class ConfigurationError(Exception):
    """Exception raised if we encounter an impossible state in a
    Configuration."""
    pass

  def __init__(self, path=None):
    """Initialize a new configuration.

    If PATH is None, try to find or create the config area in the
    standard location in the user's home directory; otherwise, find or
    create it at PATH.

    If PATH is \"-\", instantiate a Configuration object but do not
    connect it to any activity on disk; it will neither read from nor
    write to permanent storage."""

    self.config_area = path
    if self.config_area is None:
      self.config_area = os.path.join(os.path.expanduser("~"), ".onetime")
    self.pad_records_file = os.path.join(self.config_area, "pad-records")
    # Create the configuration area if necessary.
    if self.config_area != '-' and not os.path.isdir(self.config_area):
      # Legacy data check: if they have a ~/.otp dir, that's probably
      # from a previous incarnation of this program, when it was named
      # "otp".  If so, just rename the old config area.
      old_config_area = os.path.join(os.path.expanduser("~"), ".otp")
      old_pad_records_file = os.path.join(old_config_area, "pad-records")
      if os.path.isfile(old_pad_records_file):
        os.rename(old_config_area, self.config_area)
      else:
        os.mkdir(self.config_area)

    # Create the pad-records file if necessary.
    if self.config_area != '-' and not os.path.isfile(self.pad_records_file):
      open(self.pad_records_file, "w").close()
    # Parse the pad-records file (if any) in the configuration area.
    self.pad_records = self._parse_pad_records_file()
    
  def _consolidate_used_ranges(self, used, allow_reconsumption=False):
    """Return a consolidated version of USED.  USED is a list of
    tuples, indicating offsets and lengths:

       [ (OFFSET1, LENGTH1), (OFFSET2, LENGTH2), ... ]

    Consolidation means returning a list of equal or shorter length,
    that marks exactly the same ranges as used, but expressed in the
    most compact way possible.  For example:

       [ (0, 10), (10, 20), (20, 25) ]

    would become

       [ (0, 25) ]

    If ALLOW_RECONSUMPTION is False, raise a ConfigurationError
    exception if the input is incoherent, such as a range beginning
    inside another range.  But if ALLOW_RECONSUMPTION is True, allow
    ranges to overlap.  Typically, it will be False when encoding and
    True when decoding, because it's legitimate to decode a message
    multiple times, as long as no one re-uses that range for encoding."""
    new_used = [ ]
    last_offset = None
    last_length = None

    for tup in used:
      (this_offset, this_length) = tup
      if last_offset is not None:
        if last_offset + last_length >= this_offset:
          # It's only reconsumption if the end of the previous range
          # extends past the next offset.  So we error on that if
          # we're not allowing reconsumption...
          if (last_offset + last_length > this_offset
              and not allow_reconsumption):
            raise self.ConfigurationError(
              "pad's used ranges are incoherent:\n   %s" % str(used))
          # ...but otherwise we just extend the range from the
          # original offset, whether it was a true overlap or a
          # snuggle-right-up-against kind of thing:
          else:
            # All the possible cases are:
            #
            #   1) first tuple entirely precedes second
            #   2) second tuple begins inside first but ends after it
            #   3) second tuple begins and ends inside first
            #   4) second tuple begins *before* first and ends in it
            #   5) second tuple begins and ends before first
            #
            # However, due to the conditional above, we must be in (2)
            # or (3), and we only need to adjust last_length if (2).
            if (this_offset + this_length) > (last_offset + last_length):
              last_length = (this_offset - last_offset) + this_length
        else:
          new_used.append((last_offset, last_length))
          last_offset = this_offset
          last_length = this_length
      else:
        last_offset = this_offset
        last_length = this_length
    if last_offset is not None:
      new_used.append((last_offset, last_length))
    return new_used

  def _get_next_offset(self, used):
    """Return the next free offset from USED, which assumed to be in
    consolidated form.  The minimum returned is PadSession._id_source_length;
    that way the pad ID stretch is always accounted for, even if USED
    was initialized from an old original-format pad record."""
    cur_offset = None
    # We don't do anything fancy, just get the earliest available
    # offset past the last used tuple.  This means that any ranges in
    # between tuples are wasted.  See comment in main() about
    # discontinuous ranges for why this is okay.
    for tup in used:
      (this_offset, this_length) = tup
      cur_offset = this_offset + this_length
    if cur_offset is None or cur_offset < PadSession._id_source_length:
      return PadSession._id_source_length
    else:
      return cur_offset
    
  def _parse_pad_records_file(self):
    """Return a dictionary representing this configuration's 'pad-records'
    file (e.g., ~/.onetime/pad-records).  If the file is empty, just
    return an empty dictionary.

    The returned dictionary is keyed on pad IDs, with sub-dictionaries
    as values.  Each sub-dictionary's keys are the remaining element
    names inside a pad element, and the value of the 'used' element is
    a list of tuples, each tuple of the form (OFFSET, LENGTH).  So:

       returned_dict[SHA256_SUM] ==> subdict
       subdict['used'] ==> [(OFFSET1, LENGTH1), (OFFSET2, LENGTH2), ...]
       subdict['some_elt_name'] ==> SOME_ELT_VALUE       <!-- if any -->
       subdict['another_elt_name'] ==> ANOTHER_ELT_VALUE <!-- if any -->

    A 'pad-records' file is an XML document like this:

      <?xml version="1.0" encode="UTF-8"?>
      <!DOCTYPE TYPE_OF_DOC SYSTEM/PUBLIC "dtd-name">
      <onetime-pad-records>
         <pad-record>
           <id>SHA256_HASH_OF_FIRST_32_BYTES_OF_PAD</id>
           <used><offset>OFFSET_A</offset>
                 <length>LENGTH_A</length></used>
           <used><offset>OFFSET_B</offset>
                 <length>LENGTH_B</length></used>
           ...
         </pad-record>
         <pad-record>
           <id>SHA256_HASH_OF_FIRST_32_BYTES_OF_PAD</id>
           <used><offset>OFFSET_C</offset>
                 <length>LENGTH_C</length></used>
           ...
         </pad-record>
         ...
      </onetime-pad-records>
      """
    dict = { }

    if self.config_area == '-':
      return dict

    try:
      dom = xml.dom.minidom.parse(self.pad_records_file)

      for pad in dom.firstChild.childNodes:
        id = None
        path = None
        used = [ ]
        if pad.nodeType == xml.dom.Node.ELEMENT_NODE:
          subdict = { }
          for pad_part in pad.childNodes:
            if pad_part.nodeType == xml.dom.Node.ELEMENT_NODE:
              if pad_part.nodeName == "id":
                id = pad_part.childNodes[0].nodeValue
              elif pad_part.nodeName == "used":
                offset = None
                length = None
                for used_part in pad_part.childNodes:
                  if used_part.nodeName == "offset":
                    offset = int(used_part.childNodes[0].nodeValue)
                  if used_part.nodeName == "length":
                    length = int(used_part.childNodes[0].nodeValue)
                used.append((offset, length))
                subdict["used"] = self._consolidate_used_ranges(used)
              else:
                # Parse unknown elements transparently.
                subdict[pad_part.nodeName] = pad_part.childNodes[0].nodeValue
          if not subdict.has_key("used"):
            # We don't require the "used" element to be present; if it's
            # absent, it just means none of this pad has been used yet.
            subdict["used"] = [ (0, 0) ]
          dict[id] = subdict
    except xml.parsers.expat.ExpatError:
      pass
    return dict
    
  def save(self):
    """Save the pad-records file."""
    if self.config_area == '-':
      return
    tempfile = self.pad_records_file + ".tmp"
    # Deliberately not setting binary mode here; this is a text file.
    fp = open(tempfile, 'w')
    fp.write("<onetime-pad-records>\n")
    for pad_id in self.pad_records.keys():
      fp.write("  <pad-record>\n")
      fp.write("    <id>%s</id>\n" % pad_id)
      for tuple in self._consolidate_used_ranges(
          self.pad_records[pad_id]["used"]):
        fp.write("    <used><offset>%d</offset>\n" % tuple[0])
        fp.write("          <length>%d</length></used>\n" % tuple[1])
      for key in self.pad_records[pad_id].keys():
        if key != "used":
          fp.write("    <%s>%s</%s>\n" % \
                   (key, self.pad_records[pad_id][key], key))
      fp.write("  </pad-record>\n")
    fp.write("</onetime-pad-records>\n")
    fp.close()
    # On some operating systems, renaming a file onto an existing file
    # doesn't just silently overwrite the latter -- according to
    # https://github.com/kfogel/OneTime/issues/13, Microsoft Windows
    # will throw an error, for example.  So we do this rename very
    # carefully, and in such a way as to not to destroy any pad
    # records that might be left over from a past failed rename.
    intermediate_tempfile = self.pad_records_file + ".int"
    if os.path.exists(intermediate_tempfile):
      raise ConfigurationError("Leftover intermediate pad-records file found;"
                               "please sort things out:\n"
                               "  %s" % intermediate_tempfile)
    os.rename(self.pad_records_file, intermediate_tempfile)
    os.rename(tempfile, self.pad_records_file)
    os.remove(intermediate_tempfile)

  def register(self, pad_sess):
    """Register PAD_SESS's pad if it is not already registered, and
    set its offset based on previously used regions for that pad, if any."""
    next_offset = None
    # This is a little complicated only because we need; to look for
    # old original-style pad IDs and upgrade them if present.
    if not self.pad_records.has_key(pad_sess.id()):
      if self.pad_records.has_key(pad_sess.id(format_level="original")):
        # Upgrade original-style record to internal style.
        self.pad_records[pad_sess.id()] = self.pad_records[pad_sess.id(format_level="original")]
        del self.pad_records[pad_sess.id(format_level="original")]
      else:
        # Initialize a new internal-style record.
        self.pad_records[pad_sess.id()] = { "used" : [ ] }
    else:
      if self.pad_records.has_key(pad_sess.id(format_level="original")):
        raise Configuration.ConfigurationError(
          "Pad has both v2 and v1 IDs present in pad-records file:\n" \
          "  v2: %s\n"                                                \
          "  v1: %s\n"                                                \
          "This is supposed to be impossible.  Please resolve."       \
          % (pad_sess.id(), pad_sess.id(format_level="original")))
    # One way or another, we now have an up-to-date v2 pad record.
    # Set the next offset accordingly.
    next_offset = self._get_next_offset(self.pad_records[pad_sess.id()]["used"])
    pad_sess.set_offset(next_offset)

  def record_consumed(self, pad_sess, allow_reconsumption):
    """Record that PAD_SESS has used PAD_SESS.length() bytes starting
    at PAD_SESS.offset().

    If ALLOW_RECONSUMPTION is False, raise a ConfigurationError
    if reconsuming any part of a range that has been consumed previously.
    But if ALLOW_RECONSUMPTION is True, allow ranges to overlap.
    Typically, it is False when encoding and True when decoding,
    because it's okay to decode a message multiple times, but not to
    re-use a range for encoding."""
    used = self.pad_records[pad_sess.id()]["used"]
    used.append((pad_sess.offset(), pad_sess.length()))
    self.pad_records[pad_sess.id()]["used"] = self._consolidate_used_ranges(
      used, allow_reconsumption)

  def show_pad_records(self):
    """Print pad records, presumably for debugging."""
    for pad_id in self.pad_records.keys():
      print "PadSession %s:" % pad_id
      print "  used:", self.pad_records[pad_id]["used"]


def license(outfile=sys.stdout):
  """Print open source license information to OUTFILE."""
  # Looks like we're maintaining this in parallel with the LICENSE
  # file.  I'd like to avoid that, but I don't see how.  The MIT
  # license text itself won't change, but the copyright years will
  # from time to time, and the copyright holder could as well.
  license_str = """\
OneTime version %s.

Copyright (c)  2004-2016  Karl Fogel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
""" % __version__
  outfile.write(license_str)


def pad_generation_help(outfile=sys.stdout):
  """Print information on how to generate a pad."""
  help_str = """\
How to Generate a One-Time Pad
==============================

These commands will create a pad on computers that have a local source
of random bytes at /dev/random and the ability to copy those bytes
with the `dd` command.  Most GNU/Linux computers can do this.

  $ mkdir -p ~/.onetime
  $ dd if=/dev/random of=~/.onetime/to_foo.pad bs=1000 count=10000

That command will place a 10 megabyte pad in ~/.onetime/to_foo.pad
(1000000 bytes is one megabyte).  That pad will be good for encrypting
10 megabytes of data before it should be retired.  If you anticipate
sending more than 10 megabytes of data with the same pad, increase the
count accordingly.  On some computers, large pads may take a long
time, even days, to generate.  Just let dd work while you do other
things.  (Although you can go faster by using /dev/urandom instead of
/dev/random, opinion is divided on whether the random numbers from
/dev/urandom are good enough; to be safe, we recommend /dev/random,
but see http://www.2uo.de/myths-about-urandom/ for more discussion.)

To encrypt a file named WALLET.DAT with that pad:

  $ onetime -e -p ~/.onetime/to_foo.pad WALLET.DAT

(produces WALLET.DAT.onetime).
"""
  outfile.write(help_str)
  

def usage(outfile=sys.stdout):
  """Print usage information to OUTFILE."""
  usage_str = """\
OneTime version %s, an open source encryption program that uses one-time pads.

Typical usage:

  onetime -e -p PAD MSG           (encrypt; write output to 'MSG.onetime')
  onetime -d -p PAD MSG.onetime   (decrypt; output loses '.onetime' suffix)

Other usage modes:

  onetime [-e|-d] -p PAD -o OUTPUT INPUT  (both INPUT and OUTPUT are files)
  onetime [-e|-d] -p PAD -o - INPUT       (output goes to stdout)
  onetime [-e|-d] -p PAD                  (input from stdin, output to stdout)
  onetime [-e|-d] -p PAD -o OUTPUT        (input from stdin, output to OUTPUT)

OneTime remembers what ranges of what pad files have been used, and avoids
re-using those ranges when encrypting, by keeping records in ~/.onetime/.

All options:

   -e                      Encrypt
   -d                      Decrypt
   -p PAD | --pad=PAD      Use PAD for pad data.
   -o OUT | --output=OUT   Output to file OUT ("-" for stdout)
   --offset=N              Control the pad data start offset
   -n | --no-trace         Leave no record of pad usage in your config
   -C DIR | --config=DIR   Specify DIR (instead of ~/.onetime) as config area;
                           '-' for DIR means use no config area (implies -n)
   --show-id               Show a pad's ID; used with -p only
   --intro                 Show an introduction to OneTime and one-time pads
   -v | -V | --version     Show version information
   --license               Show full open source license information
   --pad-help              Show help on how to generate one-time pads
   -? | -h | --help        Show usage
""" % __version__
  outfile.write(usage_str)


def main():
  encrypting  = False
  decrypting  = False
  pad_file    = None
  incoming    = None
  output      = None
  output_name = None
  offset      = None
  config_area = None
  debug       = False
  error_exit  = False
  show_pad_id = False
  no_trace    = False

  try:
    opts, args = getopt.getopt(sys.argv[1:],
                               'edp:o:h?vVnC:',
                               [ "encrypt", "decrypt",
                                 "pad=",
                                 "output=",
                                 "offset=",
                                 "config=",
                                 "show-id",
                                 "no-trace",
                                 "debug",
                                 "intro", "help", "pad-help",
                                 "version", "license"])
  except getopt.GetoptError:
    sys.stderr.write("Error: problem processing options\n")
    usage(sys.stderr)
    sys.exit(1)

  for opt, value in opts:
    if opt == '--help' or opt == '-h' or opt == '-?':
      usage()
      sys.exit(0)
    if opt == '--pad-help':
      pad_generation_help()
      sys.exit(0)
    if opt == '--intro':
      print __doc__,
      sys.exit(0)
    elif opt == '--version' or opt == '-v' or opt == '-V':
      print "OneTime version %s" % __version__
      sys.exit(0)
    elif opt == '--license':
      license()
      sys.exit(0)
    elif opt == '--encrypt' or opt == '-e':
      encrypting = True
    elif opt == '--decrypt' or opt == '-d':
      decrypting = True
    elif opt == '--pad' or opt == '-p':
      pad_file = value
    elif opt == '--output' or opt == '-o':
      if value == "-":
        output = sys.stdout
      else:
        output_name = value
        output = open(output_name, "wb")
    elif opt == '--offset':
      offset = int(value)
    elif opt == '--config' or opt == '-C':
      config_area = value
    elif opt == '--show-id':
      show_pad_id = True
    elif opt == '--no-trace' or opt == '-n':
      no_trace = True
    elif opt == '--debug':
      debug = 1
    else:
      sys.stderr.write("Error: unrecognized option: '%s'\n" % opt)
      error_exit = True

  if show_pad_id:
    if encrypting or decrypting:
      sys.stderr.write("Error: cannot use --show-id with -e or -d.\n")
      error_exit = True
  elif not encrypting and not decrypting:
    sys.stderr.write("Error: must pass either '-e' or '-d'.\n")
    error_exit = True

  if encrypting and decrypting:
    sys.stderr.write("Error: cannot pass both '-e' and '-d'.\n")
    error_exit = True

  if not pad_file:
    sys.stderr.write("Error: must specify pad file with -p.\n")
    error_exit = True

  if len(args) == 0 or args[0] == "-":
    incoming = sys.stdin
    if output is None:
      # If incoming is stdin, output defaults to stdout.
      output = sys.stdout
  elif len(args) == 1:
    incoming = open(args[0], "rb")
    if output is None:
      if encrypting:
        # If plaintext input is 'FILENAME', output defaults to
        # 'FILENAME.onetime'.
        output_name = args[0] + ".onetime"
      else:
        # If ciphertext input is 'FILENAME.onetime', output defaults to
        # 'FILENAME'.  But we also look for ".otp", for compatibility
        # with older versions of this program.
        if args[0].endswith(".onetime"):
          output_name = args[0][:-8]
        elif args[0].endswith(".otp"):
          output_name = args[0][:-4]
        else:
          sys.stderr.write(
            "Error: input filename does not end with '.onetime' or '.otp'.\n")
          error_exit = True
      output = open(output_name, "wb")

  elif len(args) > 1:
    sys.stderr.write("Error: unexpected arguments: %s\n" % args[1:])
    error_exit = True

  if offset is not None and offset < PadSession._id_source_length:
      sys.stderr.write("Error: argument to --offset must be >= %d\n"
                       % PadSession._id_source_length)
      error_exit = True

  if error_exit:
    usage(sys.stderr)
    sys.exit(1)

  pad_sess = PadSession(pad_file)

  config = Configuration(config_area)
  config.register(pad_sess)

  if show_pad_id:
    print pad_sess.id()
    print "  Note that older versions of OneTime (v1 and before) " \
      + "would have reported"
    print "  %s.  This v1 ID output may go away" \
      % pad_sess.id(format_level="original")
    print "  in a future release, so please do not depend on its presence."
    sys.exit(0)

  if offset is not None:
    pad_sess.set_offset(offset)
    offset = None  # junk this; we'll rely on pad_sess for offset from now on

  # The first line of OneTime format level "internal" is the begin line.
  # Then comes the header: a group of lines followed by a blank line.
  # Then comes the encoded body.
  # The last line indicates the end, and is distinguishable from
  #   encoded content by inspection 
  onetime_begin = "-----BEGIN OneTime MESSAGE-----\n"
  old_onetime_begin = "-----BEGIN OTP MESSAGE-----\n"   # compat
  onetime_header = "%s" % onetime_begin                        \
               + "Format: %s" % Format_Level                   \
               + "  << NOTE: OneTime 1.x and older "           \
               +              "cannot read this format. >>\n"  \
               + "Pad ID: %s\n" % pad_sess.id()                     \
               + "Offset: %s\n" % pad_sess.offset()                 \
               + "\n"
  onetime_end = "-----END OneTime MESSAGE-----\n"
  old_onetime_end = "-----END OTP MESSAGE-----\n"       # compat

  # We could use pads more efficiently, by encrypting with multiple
  # discontinuous ranges to avoid the sparse-wasted-space problem.
  # However, the common case is that someone uses the same pad
  # successively with one interlocutor, and in that case there would
  # be no benefit to seeking out small unused ranges and consuming
  # them -- we'd pay a price in code complexity but the extra code
  # would in practice be rarely or never exercised.  Random numbers
  # aren't so expensive that they're worth that extra complexity.
  # However, we could add it in a future format rev if it ever looks
  # like a good idea.  Note that the discontinuous encrypted sections
  # would need to be embedded opaquely in the encoded output; it would
  # not be acceptable for there to be multiple plaintext "Offset:"
  # headers (or whatever) visible, as that would reveal something
  # about pad usage patterns and thus about past communications.

  if encrypting:
    output.write(onetime_header)
    encoder = PadSessionEncoder(pad_sess, config)
    while 1:
      string = incoming.read(8192)
      if len(string) > 0:
        result = encoder.encode(string)
        if result:
          output.write(result)
      else:
        result = encoder.finish()
        if result:
          output.write(result)
        break
    output.write("\n")
    output.write(onetime_end)

  elif decrypting:
    decoder = None # Will set to a decoder when know incoming format level.
    saw_end = None
    maybe_header_line = incoming.readline()
    if (maybe_header_line != onetime_begin
        and maybe_header_line != old_onetime_begin):
      sys.stderr.write("Error: malformed OneTime format: no begin line.\n")
      sys.exit(1)
    while maybe_header_line != "\n":
      maybe_header_line = incoming.readline()
      m = re.match("Offset: ([0-9]+)", maybe_header_line)
      if m:
        # Note we don't have to adjust the received offset here to
        # compensate for the 32-byte pad ID stretch, because the
        # recorded offset in *both* "original" and "internal" format
        # ciphertexts is an absolute offset from the true edge of the
        # pad.  The "internal" format pad ID stretch is already
        # reflected in the offset for modern files, and if an incoming
        # ciphertext is in original format, then naturally we just use
        # whatever offset it requests.
        #
        # (When the pad record is written back out, the 32 bytes for
        # the ID will be recorded as consumed no matter what, because
        # config.register() takes care of that.  But in practice, most
        # plaintexts will have already used more than that anyway, so
        # that safeguard is probably redundant here.)
        pad_sess.set_offset(int(m.group(1)))
        continue
      m = re.match("Format: ([a-zA-Z0-9-]+) ", maybe_header_line)
      if m:
        format_level = m.group(1)
        decoder = PadSessionDecoder(pad_sess, config, format_level)
        continue

    if decoder is None:
      # If we saw no format header, it must be the old, original format.
      decoder = PadSessionDecoder(pad_sess, config, "original")

    while 1:
      string = incoming.readline()
      if (string == onetime_end or string == old_onetime_end):
        saw_end = 1
        break
      if len(string) > 0:
        try:
          result = decoder.decode(string)
        except (IOError, PadSession.InnerFormat,
                PadSessionDecoder.DecodingError) as e:
          output.close()
          if output_name is not None:
            os.remove(output_name)
          raise e
        except EOFError:
          if string == "\n":
            # It's just the blank line between the end of the base64
            # data and the onetime_end marker.  Continue, because the
            # next thing we read should be the onetime_end marker.
            continue
          else:
            output.close()
            if output_name is not None:
              os.remove(output_name)
            raise PadSessionDecoder.DecodingError(
              "unexpected input: '%s'" % string)
        if result:
          output.write(result)
      else:
        break
    decoder.finalize()
    if not saw_end:
      sys.stderr.write("Error: malformed OneTime format: no end line.\n")
      sys.exit(1)

  if (encrypting or decrypting) and not no_trace:
    config.save()

  if debug:
    config.show_pad_records()

if __name__ == '__main__':
  main()
